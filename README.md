# Authoritative articles

1. Using your favorite DB client, design and create a table called `authors` that would store the first name, the last name, and the sex of each of the following authors:
    
      - Abi Maxwell (F)
      - Anthony Alofsin (M)
      - Emily Temple (F)
      - Gabrielle Bellot (F)
      - Meg Donohue (F)
      - Philip Eil (M)
      - Roxana Robinson (F)
      - Tobias Carroll (M)
      - Veronica Esposito (F)
     
    Don’t forget that each table must have an ID field. Please also create the necessary constraints, keys and/or indices for the table. In order to do this you might first need to read this document through the end.
     
    Copy and paste the SQL query generated by the client below:
    
    ```postgresql
    create table authors
    (
    	id serial
    		constraint authors_pk
    			primary key,
    	name text,
    	last_name text,
    	sex text
    );
    ```

2. **Manually** create a query or a series of queries filling the table with the data. Put the query/queries below:

    ```postgresql
       INSERT INTO authors (name, last_name, sex)
       VALUES ('Abi', 'Maxwell', 'F'),
              ('Anthony', 'Alofsin', 'M'),
              ('Emily', 'Temple', 'F'),
              ('Gabrielle', 'Bellot', 'F'),
              ('Meg', 'Donohue', 'F'),
              ('Philip', 'Eil', 'M'),
              ('Roxana', 'Robinson', 'F'),
              ('Tobias', 'Carroll', 'M'),
              ('Veronica', 'Esposito', 'F');
    ```

3. Using the client, design and create a table called `articles` that would store the information from the file [articles.xlsx](articles.xlsx).
 Use the already created `authors` table in order to refer to the authors. Don’t forget to create an ID field and all necessary constraints/keys/indices.

    Copy and paste the SQL query generated by the client below:

    ```postgresql
    create table articles
    (
    	id serial
    		constraint articles_pk
    			primary key,
    	title text,
    	author text,
    	date date,
    	rating double precision,
    	text text
    );
    ```

4. **Using the client**, fill the table:

    ```postgresql
    
    ```

5. Retrieve articles with the information about the author attached to each row (there should be 12 rows in the result and around 10 columns, including the article’s title, text, rating, and date as well as the author’s name and sex):

    ```postgresql
    SELECT * FROM  articles  LEFT JOIN authors ON TRIM(articles.author) = TRIM(authors.name || ' ' || authors.last_name)
    ```

6. To get the twelve rows, you must have used one of the constructions `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, or `FULL JOIN`. How many rows would the other three have returned? First try to think of the answers and then verify them by running the queries (it’s important you understand the results). Put the numbers below:

    ```
    INNER JOIN: ? rows 11
    LEFT JOIN: ? rows 12
    RIGHT JOIN: ? rows 9
    FULL JOIN: ? rows 14
    ```

7. Imagine you’re using pagination to display articles showing five articles per page. Retrieve the content for the first page: create a query that would return the latest five articles, ordered from the latest to the earliest.

    ```postgresql
    SELECT text FROM articles ORDER BY date DESC LIMIT 5
    ```

8. Retrieve the content for the second page: articles 6 through 10 (still assuming chronological order).

    ```postgresql
    SELECT text FROM articles ORDER BY date DESC LIMIT 5 OFFSET 5
    ```
    
9. Retrieve the content for the third page: articles 11 through 15 (never mind there are actually only 12 of them currently in the table).

    ```postgresql
    SELECT text FROM articles ORDER BY date DESC LIMIT 5 OFFSET 10
    ```
    
10. Count the number of five-article pages required to accommodate all articles:

    ```postgresql
    SELECT ceil(count(*)::double precision / 5) AS count_pages FROM articles
    ```
    
11. Calculate an average rating of the articles, rounded to the nearest integer:

    ```postgresql
    SELECT ROUND(AVG(rating)) AS average_rating FROM articles
    ```

12. Count males and females among the authors. There should be two rows (for males and females) and two columns: `sex` (`F` or `M`) and `cnt` (count).

    ```postgresql
    SELECT sex, COUNT(*) AS cnt FROM authors GROUP BY sex
    ```

13. Find the date of the earliest (put in the column `earliest`) and latest (put in the column `latest`) article written by each author:

    ```postgresql
    SELECT author, MIN(date) AS earliest, MAX(date) AS latest FROM articles GROUP BY author
    ```
    
14. Calculate the total length of the text written by each author (count both `text` and `title`; you can keep the tags in `text` while counting):

    ```postgresql
    SELECT SUM(length_text) AS total_length, author FROM (SELECT author, LENGTH(title || text) as length_text  FROM articles) AS text GROUP BY author
    ```
    
15. Output all the authors in a random order. There should be only one column aliased `author` with the first and last name of the author concatenated (using a space, of course). The order of the rows should be different on each request:

    ```postgresql
    SELECT (name || ' ' || last_name) AS author FROM authors order by RANDOM()
    ```

16. "Anonymize" the authors: replace each author’s last name with the properly capitalized reverse of it. E.g., `Alofsin` should become `Nisfola`, `Esposito` should become `Otisopse`, etc.

    ```postgresql
    SELECT INITCAP(REVERSE(last_name)) FROM authors
    ```
    
17. Delete all articles that don’t have an author:

    ```postgresql
    DELETE FROM articles WHERE author IS NULL
    ```

18. **(optional)** Delete all authors that haven’t written any articles:

    ```postgresql
    DELETE FROM authors WHERE NOT TRIM(authors.name || ' ' || authors.last_name) IN (SELECT author FROM articles)
    ```

Don’t forget to create a pull request.
